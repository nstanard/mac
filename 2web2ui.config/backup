
# ACCESS.LUA FILE
# mkdir -p "$SP_REPOS/Ansible-Deployment/roles/access_lua/files/"
# touch "$SP_REPOS/Ansible-Deployment/roles/access_lua/files/access.lua"
# cat > "$SP_REPOS/Ansible-Deployment/roles/access_lua/files/access.lua" <<-EOF
# -- Ansible-managed roles/access_lua
# -- per nginx lua module docs: when you need to read from an Nginx variable repeatedly in your Lua code,
# -- cache the Nginx variable value to your own Lua variable
# local start_time = ngx.now()
# local uri = ngx.var.uri
# local request_method = ngx.var.request_method
# local function setAuthTime()
#     ngx.req.set_header('x-msys-auth-time', ngx.now() - start_time)
# end
# -- only want to mess with api access points
# if string.len(uri) < 8 or ((string.sub(uri, 1, 7) ~= '/api/v1') and (string.sub(uri, 1, 9) ~= '/api/labs')) then
#     -- Used for SMTP Authentication, if /access is changed, please update here too!
#     if (uri == '/access' and ngx.var.internal_tenant_id ~= '') then
#         local smtpArgs = ngx.req.get_uri_args()
#         smtpArgs.tenant = ngx.var.internal_tenant_id
#         ngx.req.set_uri_args(smtpArgs);
#     end
#     setAuthTime()
#     return;
# end
# if (request_method == 'GET') then
#     -- momo UI
#     if (uri == '/api/v1/metrics/configuration') then
#     setAuthTime()
#         return;
#     end
#     if (string.sub(uri, 1, 24) == '/api/v1/webhooks/events/') then
#         setAuthTime()
#         return;
#     end
#     if (string.sub(uri, 1, 30) == '/api/v1/message-events/events/') then
#         setAuthTime()
#         return;
#     end
#     if (string.sub(uri, 1, 29) == '/api/v1/ingest/events/samples') then
#         setAuthTime()
#         return;
#     end
#     if (string.sub(uri, 1, 35) == '/api/v1/ingest/events/documentation') then
#         setAuthTime()
#         return;
#     end
#     if (string.sub(uri, 1, 30) == '/api/v1/events/message/samples') then
#         setAuthTime()
#         return;
#     end
#     if (string.sub(uri, 1, 36) == '/api/v1/events/message/documentation') then
#         setAuthTime()
#         return;
#     end
#     if (string.sub(uri, 1, 29) == '/api/v1/events/ingest/samples') then
#         setAuthTime()
#         return;
#     end
#     if (string.sub(uri, 1, 35) == '/api/v1/events/ingest/documentation') then
#         setAuthTime()
#         return;
#     end
#     -- sparkpost only
#     if (string.sub(uri, 1, 21) == '/api/v1/users/invite/') then
#         setAuthTime()
#         return;
#     end
#     if (string.sub(uri, 1, 25) == '/api/v1/account/countries') then
#         setAuthTime()
#         return;
#     end
#     -- can be removed after FAD-2213 is deployed to SPE
#     if (string.sub(uri, 1, 24) == '/api/v1/users/saml/login') then
#         setAuthTime()
#         return;
#     end
#     if (string.match(uri, '/api/v1/users/%S+/saml$')) then
#         setAuthTime()
#         return;
#     end
# end
# if (request_method == 'POST') then
#     if (uri == '/api/v1/users/password/forgot') then
#         setAuthTime()
#         return;
#     end
#     if (uri == '/api/v1/account') then
#         setAuthTime()
#         return;
#     end
#     if (string.sub(uri, 1, 23) == '/api/v1/users/register/') then
#         setAuthTime()
#         return;
#     end
#     -- can be removed after FAD-2213 is deployed to SPE
#     if (string.sub(uri, 1, 26) == '/api/v1/users/saml/consume') then
#         setAuthTime()
#         return;
#     end
#     if (string.match(uri, '/api/v1/authenticate/logout/?$')) then
#         setAuthTime()
#         return;
#     end
# end
# if (string.match(uri, '/api/v1/authenticate/?$')) then
#     setAuthTime()
#     return;
# end
# -- allow inbox placement integration endpoints (e.g., webhook consumers), auth will be enforced in the service layer
# if (string.sub(uri, 1, 36) == '/api/v1/inbox-placement/integrations') then
#     setAuthTime()
#     return;
# end
# -- allow all /sso routes, they will be authenticated with passport
# if (string.sub(uri, 1, 17) == '/api/v1/users/sso') then
#     setAuthTime()
#     return;
# end
# -- sparkpost only
# if (string.sub(uri, 1, 28) == '/api/v1/account/integrations') then
#   local isAuthenticationRequired = false
#   if (string.find(uri, '/control')) then
#     isAuthenticationRequired = true
#   end
#   if (isAuthenticationRequired == false) then
#     setAuthTime()
#     return;
#   end
# end
# if (string.sub(uri, 1, 23) == '/api/v1/messaging-tools') then
#   local isAuthenticationRequired = false
#   if (ngx.req.get_headers()['Authorization'] ~= nil and (not string.find(uri, '/inbound'))) then
#     isAuthenticationRequired = true
#   end
#   if (string.find(uri, 'ping')) then
#     isAuthenticationRequired = true
#   end
#   if (string.find(uri, '/control')) then
#     isAuthenticationRequired = true
#   end
#   if (string.find(uri, 'spf/history')) then
#     isAuthenticationRequired = true
#   end
#   if (isAuthenticationRequired == false) then
#     setAuthTime()
#     return;
#   end
# end
# -- support for Basic auth ("Authorization": "Basic " + base64_encode(API Key))
# -- remote_user is the already-decoded user from the basic auth (hence the accessToken here)
# local basicAuthUser = ngx.var.remote_user
# if basicAuthUser then
#     ngx.req.set_header('Authorization', basicAuthUser)
# end
# local accessToken = ngx.var.http_authorization
# if not accessToken then
#     ngx.status = ngx.HTTP_UNAUTHORIZED
#     ngx.header['Content-Type'] = 'application/json'
#     ngx.say('{\"errors\": [ {\"message\": \"Unauthorized.\"} ]}')
#     setAuthTime()
#     return ngx.exit(ngx.HTTP_OK)
# end
# local ipAddress = ngx.var.http_x_real_ip
# local subaccount = ngx.var.http_x_msys_subaccount
# local tenant = ngx.var.http_x_msys_tenant
# -- Used for REST API Authentication, if updating, be sure to update the SMTP Authentication stanza above!
# local res = ngx.location.capture('/access?access_token=' .. ngx.escape_uri(accessToken) .. '&resource_uri=' .. ngx.escape_uri(uri) .. '&resource_method=' .. request_method  .. '&client_ip=' .. ngx.escape_uri(ipAddress) .. '&tenant=' .. ngx.escape_uri(tenant) .. '&subaccount=' .. ngx.escape_uri(subaccount))
# local cjson = require 'cjson.safe'
# local accessResp = cjson.decode(res.body)
# if (accessResp == nil) then
#     -- Cannot decode response from /access endpoint
#     -- This can happen if /access returns a 50x error or res.truncated is true(aka incomplete res.body)
#     ngx.header['Content-Type'] = 'application/json'
#     -- Respond with 503
#     ngx.status = ngx.HTTP_SERVICE_UNAVAILABLE
#     ngx.say('{\"errors\": [ {\"message\": \"Unable to contact authorization service.\"} ]}')
#     ngx.log(ngx.ERR, 'nil response from /access')
#     setAuthTime()
#     return ngx.exit(ngx.HTTP_OK)
# elseif accessResp.query_params ~= nil and accessResp.query_params.access_token ~= accessToken then
#     -- check if the access token returned from auth is the same as what was passed in. Respond with a 500 error
#     ngx.status = ngx.HTTP_INTERNAL_SERVER_ERROR
#     ngx.header['Content-Type'] = 'application/json'
#     ngx.say('{\"errors\": [ {\"message\": \"Internal Server Error.\"} ]}')
#     setAuthTime()
#     return ngx.exit(ngx.HTTP_OK)
# else
#     if (accessResp.access == true) then
#         -- unset X-MSYS-SUBACCOUNT, if it's valid/present, we'll reset it below
#         ngx.req.set_header('X-MSYS-SUBACCOUNT', nil);
#         -- Add user headers, forward request on
#         ngx.req.set_header('X-MSYS-CUSTOMER', accessResp.customer)
#         ngx.req.set_header('X-MSYS-USERNAME', accessResp.user)
#         ngx.req.set_header('X-MSYS-KEY-TYPE', accessResp.key_type)
#         -- Needed for TR mirroring, for some reason mirrored subrequests
#         -- always have X-MSYS-CUSTOMER set to 1 (from the more_set_input_headers from the server directive)
#         -- putting it in another header makes it available for use in the mirrored location
#         ngx.req.set_header('X-MSYS-CUSTOMER-STASH', accessResp.customer)
#         if accessResp.subaccount then
#           ngx.req.set_header('X-MSYS-SUBACCOUNT', accessResp.subaccount)
#         end
#     setAuthTime()
#     else
#         --ngx.header['Content-Type'] = 'application/json'
#         --if res.status == 401 then
#         --    ngx.status = ngx.HTTP_UNAUTHORIZED
#         --    ngx.say('{\"errors\": [ {\"message\": \"Unauthorized.\"} ]}')
#         --else
#         --    ngx.status = ngx.HTTP_FORBIDDEN
#         --    ngx.say('{\"errors\": [ {\"message\": \"Forbidden.\"} ]}')
#         --end
#         --setAuthTime()
#         --return ngx.exit(ngx.HTTP_OK)
#     end
# end

# EOF

# TODO - hook these chown calls up so brew can start openresty without sudo
# sudo chown $USER /usr/local/var/log/openresty/error.log
# sudo chown $USER /usr/local/var/log/openresty/access.log
# sudo chown $USER /usr/local/var/log/openresty/phoenix-ui.error.log
# sudo chown $USER /usr/local/var/log/openresty/tools.error.log
# sudo chown $USER /usr/local/var/log/openresty/api.error.log
# sudo chown $USER /usr/local/var/log/openresty/ui-errors.log

# TODO: Add sparkposttest aws config setup
# [profile sparkposttest]
# region = us-west-2

# TODO: require accusers-api repo
# if [ ! -d "$SP_REPOS/accusers-api" ]; then
#   echo ""
#   echo "Missing $SP_REPOS/accusers-api"
#   echo ""
#   exit 0
# fi





# ACCUSERS_API_DOWNLOAD_LINK="https://github.com/SparkPost/accusers-api/archive/master.zip"
# echo ""
# read -p "Would you like to download the Accusers-API for 2web2ui? [Y/n]: " response
# response=${response:-y}
# if [ "$response" = "y" ]; then
#   sudo curl -o "/tmp/${ACCUSERS_API_DOWNLOAD_LINK##*/}" "$ACCUSERS_API_DOWNLOAD_LINK"
# fi





# TODO: get openresty configs writing to the right files (correctly... right now it's breaking)
# OPENRESTY CONFIGURATION
# echo ""
# read -p "Would you like to configure openresty for 2web2ui? [Y/n]: " response
# response=${response:-y}
# if [ "$response" = "y" ]; then
# todo: log folder
# mkdir -p /usr/local/var/log/openresty
# chmod 755 /usr/local/var/log/openresty
# touch /usr/local/var/log/openresty/error.log
# 
#   # Nginx.conf
#   touch "/usr/local/etc/openresty/nginx.conf"
#   cat > "/usr/local/etc/openresty/nginx.conf" <<-EOF
# worker_processes 2;

# events {
#   worker_connections 256;
# }

# error_log /usr/local/var/log/openresty/error.log debug;
# http {
#   include mime.types;
#   default_type application/octet-stream;

#   log_format main ‘$remote_addr - $remote_user [$time_local] $status ’
#     ‘“$request” $body_bytes_sent “$http_referer” ’
#     ‘“$http_user_agent” “http_x_forwarded_for”’;

#   access_log /usr/local/var/log/openresty/access.log main;

#   sendfile on;

#   tcp_nopush on;
#   tcp_nodelay off;

#   keepalive_timeout 65;

#   gzip on;
#   gzip_http_version 1.0;
#   gzip_comp_level 2;
#   gzip_proxied any;

#   include /usr/local/etc/openresty/sites/*.conf;
# }
# EOF

#   touch "/usr/local/etc/openresty/cors"
#   cat > "/usr/local/etc/openresty/cors" <<-EOF
# more_set_headers 'Access-Control-Allow-Origin: $http_origin';
# more_set_headers 'Access-Control-Allow-Methods: GET, POST, PUT, DELETE, PATCH, OPTIONS';
# more_set_headers 'Access-Control-Allow-Credentials: true';

# if ($request_method = 'OPTIONS') {
#   more_set_headers 'Access-Control-Max-Age: 1728000';
#   more_set_headers 'Access-Control-Allow-Headers: Authorization,Content-Type,Accept,Origin,User-Agent,DNT,Cache-Control,X-Mx-ReqToken,Keep-Alive,X-Requested-With,If-Modified-Since,X-Msys-Subaccount,X-Sparky,Cookie';
#   more_set_headers 'Content-Length: 0';
#   more_set_headers 'Content-Type: text/plain; charset=UTF-8';
#   return 204;
# }
# EOF

#   # Overrides.loc
#   touch "/usr/local/etc/openresty/overrides.loc"
#   cat > "/usr/local/etc/openresty/overrides.loc" <<-EOF
# # Configure override routes to point to your local service (don't forget to `sudo brew services restart openresty`)
# #
# # location /api/labs/snippets {
# #   proxy_pass http://localhost:3002;
# #   include cors;
# # }
# #
# # location /api/v1/templates {
# #   proxy_pass http://localhost:3002;
# #   include cors;
# # }
# location /api/v1/delegated-domains {
#   proxy_pass http://localhost:3000;
#   include cors;
# }
# EOF

#   # Sparkpost.conf
#   mkdir -p "/usr/local/etc/openresty/sites"
#  chmod 755 "/usr/local/etc/openresty/sites"
#   touch "/usr/local/etc/openresty/sites/sparkpost.conf"
#   cat > "/usr/local/etc/openresty/sites/sparkpost.conf" <<-EOF
# proxy_cache_path /tmp/control-cache keys_zone=control:1m;
# log_format uierr '$msec "$proxy_add_x_forwarded_for" $http_user_agent "$request_body"';
# server {
#   listen      80;
#   server_name legacy-app.sparkpost.test;
#   more_set_headers 'Server: msys-http';
#   more_clear_headers 'X-Powered-By';
#   # compression
#   gzip on;
#   gzip_proxied any;
#   gzip_comp_level 5;
#   gzip_types text/plain text/css text/js application/x-javascript text/javascript application/javascript application/json;
#   gzip_min_length 1100;
#   gzip_buffers 4 32k;
#   # logging
#   error_log /usr/local/var/log/openresty/app.error.log info;
#   # static files
#   location / {
#     index  index.html;
#     try_files $uri $uri/ /index.html;
#     root $SP_REPOS/webui/src;
#   }
# }
# # Phoenix UI
# # (for local dev, upstream to webpack-dev-server)
# server {
#   listen      80;
#   server_name app.sparkpost.test;
#   proxy_redirect off;
#   proxy_http_version 1.1;
#   # web-socket proxying for live-reload type connection
#   # http://nginx.org/en/docs/http/websocket.html
#   proxy_set_header Upgrade $http_upgrade;
#   proxy_set_header Connection "upgrade";
#   # logging
#   error_log /usr/local/var/log/openresty/phoenix-ui.error.log info;
#   # proxy pass to localhost:3100 webpack-dev-server
#   location / {
#     proxy_pass http://localhost:3100;
#   }
# }
# # messaging tools ui
# # (for local dev, upstream to webpack-dev-server)
# server {
#   listen      80;
#   server_name tools.sparkpost.test;
#   proxy_redirect off;
#   proxy_http_version 1.1;
#   # web-socket proxying for live-reload type connection
#   # http://nginx.org/en/docs/http/websocket.html
#   proxy_set_header Upgrade $http_upgrade;
#   proxy_set_header Connection "upgrade";
#   # logging
#   error_log /usr/local/var/log/openresty/tools.error.log info;
#   # proxy pass to localhost:3000 webpack-dev-server
#   location / {
#     proxy_pass http://localhost:3000;
#   }
# }
# server {
#   listen      80;
#   server_name api.sparkpost.test;
#   more_set_headers 'Server: msys-http';
#   more_clear_headers 'X-Powered-By';
#   # compression
#   gzip on;
#   gzip_proxied any;
#   gzip_comp_level 5;
#   gzip_types text/plain text/css text/js application/x-javascript text/javascript application/javascript application/json;
#   gzip_min_length 1100;
#   gzip_buffers 4 32k;
#   # logging
#   error_log /usr/local/var/log/openresty/api.error.log info;
#   set_by_lua_file $x_forward "$SP_REPOS/accusers-api/nginx/get-forwarded-for.lua";
#   #setting x-forwarded-for to the left-most ip address, more accurate for location
#   more_set_input_headers 'X-Forwarded-For: $x_forward';
#   more_set_input_headers 'X-Real-Ip: $x_forward';
#   more_set_input_headers 'X-MSYS-CUSTOMER: 1';
#   more_set_input_headers 'X-MSYS-TENANT: staging';
#   access_by_lua_file "$SP_REPOS/Ansible-Deployment/roles/access_lua/files/access.lua";
#   proxy_set_header  Host $http_host;
#   proxy_redirect    off;
#   proxy_max_temp_file_size 0;
#   proxy_intercept_errors on;
#   location /uilog {
#     access_log /usr/local/var/log/openresty/ui-errors.log uierr;
#     echo_read_request_body;
#     echo $request_body;
#     include cors;
#     client_max_body_size 1k;
#   }
#   location /api {
#     error_page 502 503 504 @jsonerror;
#     error_page 404 @json_error404;
#     more_set_headers 'Cache-Control: no-cache, no-store';
#     include overrides.loc;
#     proxy_pass http://app.stg.sparkpost:8888;
#     include cors;
#   }
#   location /access {
#     error_page 500 502 503 504 @jsonerror;
#     error_page 404 @json_error404;
#     proxy_set_header  Accept  "application/json";
#     proxy_pass http://app.stg.sparkpost/access;
#     include cors;
#   }
#   location @jsonerror {
#     include cors;
#     more_set_headers 'Content-Type: application/json';
#     echo '{"errors": [ {"message": "Could not proceed ($status error)"} ] }';
#   }
#   location @json_error404 {
#     include cors;
#     more_set_headers 'Content-Type: application/json';
#     echo '{"errors": [ { "message": "Resource could not be found"} ] }';
#   }
# }
# server {
#   listen 8888;
#   server_name api.sparkpost.test;
#   # logging
#   error_log /usr/local/var/log/openresty/api.error.log info;
#   access_log /usr/local/var/log/openresty/access.log main;
#   set_by_lua_file $x_forward "$SP_REPOS/accusers-api/nginx/get-forwarded-for.lua";
#   # includes/gzip_directives.j2
#   gzip on;
#   gzip_proxied any;
#   gzip_comp_level 5;
#   gzip_types text/plain application/json;
#   gzip_min_length 1100;
#   gzip_buffers 4 32k;
#   proxy_set_header  X-Real-IP $remote_addr;
#   # includes/proxy_directives.j2
#   proxy_set_header  X-Forwarded-For $proxy_add_x_forwarded_for;
#   proxy_set_header  Host $http_host;
#   proxy_redirect    off;
#   proxy_max_temp_file_size 0;
#   proxy_intercept_errors on;
#   location /api {
#     error_page 502 503 504 @jsonerror;
#     error_page 404 @json_error404;
#     more_set_headers 'Cache-Control: no-cache, no-store';
#     include overrides.loc;
#     proxy_pass http://app.stg.sparkpost:8888;
#     include cors;
#   }
#   location @jsonerror {
#     include cors;
#     more_set_headers 'Content-Type: application/json';
#     more_set_headers 'Cache-Control: no-cache, no-store';
#     echo '{"errors": [ {"message": "Could not proceed ($status error)"} ] }';
#   }
#   location @json_error404 {
#     include cors;
#     more_set_headers 'Content-Type: application/json';
#     more_set_headers 'Cache-Control: no-cache, no-store';
#     echo '{"errors": [ {"message": "Resource could not be found"} ] }';
#   }
# }
# EOF
# fi


